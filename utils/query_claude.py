from dotenv import load_dotenv
from retry import retry
import anthropic
from utils.estimate_costs import estimate_costs
from configs import MODEL, MODELS
import re
import logging

from anthropic.types import (
    ContentBlock,
    ContentBlockDeltaEvent,
    ContentBlockStartEvent,
    ContentBlockStopEvent,
    ImageBlockParam,
    Message,
    MessageDeltaEvent,
    MessageDeltaUsage,
    MessageParam,
    MessageStartEvent,
    MessageStopEvent,
    MessageStreamEvent,
    TextBlock,
    TextBlockParam,
    TextDelta,
    Usage,
)


def ai_cleanup(text: str) -> tuple[str, int]:

    prompt = get_prompt(text)
    model = get_model(MODEL)

    try:
        response = query_claude(model, prompt)
    except Exception as e:
        logging.warning(e)
        return e.__repr__(), 0

    completion = response.content[0].text
    answer = parse_completion(completion)
    costs = estimate_costs(response)

    return answer, costs


def get_prompt(text: str) -> str:
    return f"""<text>{text}</text>

This text was transcribed by OCR. Your job is to fix obvious transcription errors, such                     as problems with word separation, punctuation, encoding. Output only the corrected text. Output the answer within  <answer> tags. Only correct issues which would be generated by a bad transcription. Don't correct stylistic choices, local accents or the logical flow of sentences. If the last sentence looks like it continues in the next page, do not put a period at the end; otherwise, put periods at the end of the last sentence. Leave the \u2026 as-is, without changing to '...'. Use UK English."""


# @retry(tries=10, delay=1, backoff=2)
def query_claude(model: str, prompt: str) -> Message:
    load_dotenv()
    client = anthropic.Anthropic()

    message = client.messages.create(
        model=model,
        max_tokens=1024,
        temperature=0,
        messages=get_messages(prompt),
    )
    return message


def get_messages(prompt: str) -> list[MessageParam]:
    message: MessageParam = {"role": "user", "content": prompt}
    return [message]


def parse_completion(completion: str) -> str:
    answer_pattern = r"<answer>(.*?)</answer>"
    answer_match = re.search(answer_pattern, completion, re.DOTALL)
    answer_text = answer_match.group(1).strip() if answer_match else "No answer found."
    return answer_text


def get_model(model_name: str) -> str:
    model = next((model["id"] for model in MODELS if model["name"] == model_name), None)
    if model is None:
        raise ValueError(f"Model {model_name} not found in {MODELS}.")
    return model
