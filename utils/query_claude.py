from dotenv import load_dotenv
from retry import retry
import anthropic
from utils.estimate_costs import estimate_costs
from configs import MODEL, MODELS
import re


from anthropic.types import (
    ContentBlock,
    ContentBlockDeltaEvent,
    ContentBlockStartEvent,
    ContentBlockStopEvent,
    ImageBlockParam,
    Message,
    MessageDeltaEvent,
    MessageDeltaUsage,
    MessageParam,
    MessageStartEvent,
    MessageStopEvent,
    MessageStreamEvent,
    TextBlock,
    TextBlockParam,
    TextDelta,
    Usage,
)


def ai_cleanup(text: str, page: str) -> str:

    prompt = get_prompt(text)
    model = get_model(MODEL)

    try:
        response = query_claude(model, prompt)
    except Exception as e:
        print(e)

    print("\tpage ", page)
    print("\t\t", estimate_costs(response))

    completion = response.content[0].text
    logs, answer = parse_completion(completion)

    print("\t\t", logs.replace("\n", "\n\t\t"))

    return answer


def get_prompt(text: str) -> str:
    return f"<text>{text}</text>\n\nThis text was transcribed by OCR. Your job is to fix obvious transcription errors, such as problems with word separation, punctuation, encoding. Output a concise log of changes in a <log> tag and then output the answer in a <answer> tag. Only correct issues which would be generated by a bad transcription. Don't correct stylistic choices or the logical flow of sentences. Use UK English (that is, do not correct things like 'behaviour' to 'behavior')."


# @retry(tries=10, delay=1, backoff=2)
def query_claude(model: str, prompt: str) -> Message:
    load_dotenv()
    client = anthropic.Anthropic()

    message = client.messages.create(
        model=model,
        max_tokens=1024,
        temperature=0,
        messages=get_messages(prompt),
    )
    return message


def get_messages(prompt: str) -> list[MessageParam]:
    message: MessageParam = {"role": "user", "content": prompt}
    return [message]


def parse_completion(completion: str) -> tuple[str, str]:
    log_pattern = r"<log>(.*?)</log>"
    answer_pattern = r"<answer>(.*?)</answer>"

    log_match = re.search(log_pattern, completion, re.DOTALL)
    answer_match = re.search(answer_pattern, completion, re.DOTALL)

    log_text = log_match.group(1).strip() if log_match else "No log found."
    answer_text = answer_match.group(1).strip() if answer_match else "No answer found."

    return log_text, answer_text


def get_model(model_name: str) -> str:
    model = next((model["id"] for model in MODELS if model["name"] == model_name), None)
    if model is None:
        raise ValueError(f"Model {model_name} not found in {MODELS}.")
    return model
